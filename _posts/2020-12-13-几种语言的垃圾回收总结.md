---
layout: post
categories: JAVA python nodejs ruby
---

# 几种常见语言
## PYTHON
* 引用计数： 简单，缺点：无法解决循环引用
* 标记-清除：
    * 先暂停线程，标记，区分死亡队列和活队列
    * 遍历存活容器，若引用死亡队列，则复活
    * 清除死亡队列
* 分代收集
    * 代数越高的对象，执行标记清除的间隔就越长

## Nodejs
* 分为新生代和老生代
* 新生代采用scavenge算法，一分为二，From、To
* 老年代采用标记清除，标记整理(清理完后整理)
* 早期V8采用全停顿，100毫秒，后期引入增量标记，每次控制在5毫秒

##  java
* 新生代：serial，ParNew， Parellel Scavenge(达到可控的吞吐量，适合后台计算任务)
* 老生代：serial Old，Parallel Old(PS mark sweep 吞吐量优先)、CMS（concurent mark-sweep 停顿时间优先，基于标记-清除，产生碎片）
* 按区域：G1（Garbage first）区分为不同的Region
    * 跨区域引用问题：每个Region维护一个记忆集()
    * 标记阶段如何保证用户线程并行？CMS是增量更新，G1是原始快照算法
    * 停顿预测模型：基于统计信息
* 其它低延时，停顿控制在10ms之内
    * Shenandoah：继承G1，记忆集改为邻接矩阵，Oracle不承认
        * 转发指针
        * 开始采用了读屏障，改为引用访问屏障
    * ZGG：采用了染色指针
        * 没有使用记忆集，
        * 控制了停顿时间，但有可能回收的慢
  
## ruby
* ruby采用的是可用列表方式
* 使用John-MaCarthy的原生“标记并清除”算法

## PHP：
* 以php的引用计数机制为基础（php5.3以前只有该机制）
* 使用根缓冲区机制，当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题（php5.3开始引入该机制）
## GO:
* golang 中采用 span 数据结构管理内存
* 三色标记法
* 写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障在 GC 的特定时间开启，开启后指针传递时会把指针标记，即本轮不回收，下次 GC 时再确定
* 为了防止内存分配过快，在 GC 执行过程中，GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作

# 三色标记法说明
在遍历对象图的过程中，把访问都的对象按照"是否访问过"这个条件标记成以下三种颜色：

- 白色：表示对象尚未被垃圾回收器访问过。显然，在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 黑色：表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其它的对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色：表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过。
- 
<p align="center">
<img src="https://imgedu.lagou.com/3549f7a1591f4adb943eaeea61c087fc.jpg"  width="60%"   />
</p>


* Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：
    * ·赋值器插入了一条或多条从黑色对象到白色对象的新引用；
    * ![](https://imgedu.lagou.com/b61c43447384403481533184f39086c0.jpg)
    * ·赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。
    * ![](https://imgedu.lagou.com/6ac50abcd9fd4370b2be2d5c6713c92a.jpg)
* 因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：增量更新（IncrementalUpdate）和原始快照（SnapshotAtTheBeginning，SATB）。
  * 增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
  * ![](https://imgedu.lagou.com/4f6ebd6332194b9f86e2919915ed82dd.jpg)
  * 原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。
  * ![](https://imgedu.lagou.com/350302ec19e347d793e10e59e5051b12.jpg)
  * 以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。
  * 在HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现。
    * 增量更新用的是写后屏障(Post-Write Barrier)，记录了所有新增的引用关系。
    * 原始快照用的是写前屏障(Pre-Write Barrier)，将所有即将被删除的引用关系的旧引用记录下来。

# 参考
* [Python垃圾回收机制！非常实用](https://zhuanlan.zhihu.com/p/83251959)
* [【Python垃圾回收机制--完美讲解!](https://blog.csdn.net/LuckyQueen0928/article/details/96044552)
* [nodejs中的垃圾回收机制](https://www.cnblogs.com/itstone/p/10477250.html)
* [[转载]Python垃圾回收机制--完美讲解!](https://www.jianshu.com/p/1e375fb40506)  ruby的部分
* [php底层原理之垃圾回收机制](https://juejin.cn/post/6844903788810092557)
* [浅析 Golang 垃圾回收机制](https://developer.aliyun.com/article/775798)
* 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版
* [你说你熟悉jvm?那你讲一下并发的可达性分析](https://www.lagou.com/lgeduarticle/101831.html) : 很不错的一篇文章，动图，讲解的很好