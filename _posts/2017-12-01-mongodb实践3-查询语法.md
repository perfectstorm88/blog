---
layout: post
categories: mongodb 数据库
---

Mongodb的查询语法，内容比较多，这里对常用的一些语句进行了记录

# 基本操作
[MongoDB基本使用](http://www.cnblogs.com/TankMa/archive/2011/06/08/2074947.html):整理的很全面

## 创建表和索引
[给MongoDB添加索引](http://blog.163.com/ji_1006/blog/static/10612341201311243825985/)
db.createCollection("brother1s") --- 创建表
db.brother1s.ensureIndex({"name":1},{"unique":true})--创建索引

## 最简单的增删改查
输入help可以看到基本操作命令：
- show dbs:显示数据库列表 
- show collections：显示当前数据库中的集合（类似关系数据库中的表） 
- show users：显示用户
- use <db name>：切换当前数据库，这和MS-SQL里面的意思一样 
- db.help()：显示数据库操作命令，里面有很多的命令 
- db.foo.help()：显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令 
- db.foo.find()：对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据） 
- db.foo.find( { a : 1 } )：对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1


```sql
db.person.find();
db.person.insert({"name":"jack","age":20});
db.person.update({"name":"jack"},{"name":"jack","age":30});
db.person.remove({"name":"jack"});
db.person.count();
```

mongo命令打开的是一个javascript shell,所以可以直接用js语法

```sql
var p={"name":"jack","age":20};
db.person.insert(p);
p.name="marry";
db.person.insert(p);
db.person.find();
```
## 修改字段命名
db.test.update({}, {$rename : {"oldname" : "newname"}}, false, true)

## 数组操作
### 查询数组中的一个元素
```
db.getCollection('balancesheets').find({_id:ObjectId("56cea0699a3bec4b54a7d7fc"),'balances.subject':'1002'},{'balances.$':1})
```
### 更新数组中一个元素的某个字段
```
db.getCollection('fixedassets').update({_id:ObjectId("571050e4791c6a5a5b492bd1"),"items.key":"123"},
{$set:{"items.$.abc":"test"}}，{multi:true})
```
说明： 若document的数组中有多个满足条件的子元素，只能更新一个子元素的值
参见：http://stackoverflow.com/questions/4669178/how-to-update-multiple-array-elements-in-mongodb 给出的方法，只能查找遍历修改，然后再保存对象

### 更新数组中一个元素
```
db.getCollection('fixedassets').update({_id:ObjectId("571050e4791c6a5a5b492bd1"),"items._id":ObjectId("571050e4791c6a5a5b492bd2")},
{$set:{"items.$":{
    "_id" : ObjectId("571050e4791c6a5a5b492bd2"),
    "initVal" : 41699.15,
    "depreciationPeriod" : 36,
    "residualVal" : 2084.96,
    "abc" : "test1"
}}})
```
### 删除数组中一个元素
这个语句只会置为null，不会删除这个元素
```
db.getCollection('fixedassets').update({_id:ObjectId("571050e4791c6a5a5b492bd1"),"items._id":ObjectId("571050e4791c6a5a5b492bd2")},
{$unset:{"items.$":""}})
```



# 查询
## 一般查询语法
http://www.nonb.cn/blog/mongodb-advanced-queries.html
WHERE查询
// i.e., select * from things where x=3 and y="foo"
db.things.find( { x : 3, y : "foo" } );

存储数组元素
db.things.insert({colors : ["blue", "black"]})
db.things.insert({colors : ["yellow", "orange", "red"]})
//查询结果
db.things.find({colors : {$ne : "red"}})
{"_id": ObjectId("4dc9acea045bbf04348f9691"), "colors": ["blue","black"]}
 

对比操作符
$ne 不等于
db.collection.find({ "field" : { $gt: value } } );   // greater than  : field > value
db.collection.find({ "field" : { $lt: value } } );   // less than  :  field < value
db.collection.find({ "field" : { $gte: value } } );  // greater than or equal to : field >= value
db.collection.find({ "field" : { $lte: value } } );  // less than or equal to : field <= 
 

$all 全部属于
db.things.find( { a: { $all: [ 2, 3 ] } } )
 

$exists 字段存在
db.things.find( { a : { $exists : true } } )
db.things.find( { a : { $exists : false } } )
true返回存在字段a的数据，false返回不存在字度a的数据。
 

$mod 取模运算
db.things.find( { a : { $mod : [ 10 , 1 ] } } )
条件相当于a % 10 == 1 即a除以10余数为1的。

$in 属于
db.things.find({j:{$in: [2,4,6]}})
条件相当于j等于[2,4,6]中的任何一个。
 

$nin 不属于
db.things.find({j:{$nin: [2,4,6]}})
条件相当于 j 不等于 [2,4,6] 中的任何一个。
 

$or 或 （注意：MongoDB 1.5.3后版本可用）
db.foo.find( { $or : [ { a : 1 } , { b : 2 } ] } )
符合条件a=1的或者符合条件b=2的数据都会查询出来。
 

$size 数量，尺寸
db.things.find( { a : { $size: 1 } } )
条件相当于a的值的数量是1（a必须是数组，一个值的情况不能算是数量为1的数组）。
 

$type 字段类型
db.things.find( { a : { $type : 2 } } )
条件是a类型符合的话返回数据。
 

limit() skip()
这两个ME想连起来讲，他们就是你实现数据库分页的好帮手。
limit()控制返回结果数量，如果参数是0，则当作没有约束，limit()将不起作用。
skip()控制返回结果跳过多少数量，如果参数是0，则当作没有约束，skip()将不起作用，或者说跳过了0条。
例如：
 db.test.find().skip(5).limit(5)
结果就是取第6条到第10条数据。
snapshot()   （没有尝试）
count()   条数
返回结果集的条数。
db.test.count()
在加入skip()和limit()这两个操作时，要获得实际返回的结果数，需要一个参数true，否则返回的是符合查询条件的结果总数。
例子如下：
$elemMatch
如果对象有一个元素是数组，那么$elemMatch可以匹配内数组内的元素：
 t.find( { x : { $elemMatch : { a : 1, b : { $gt : 1 } } } } ) 
{ "_id" : ObjectId("4b5783300334000000000aa9"), 
"x" : [ { "a" : 1, "b" : 3 }, 7, { "b" : 99 }, { "a" : 11 } ]
}
$elemMatch : { a : 1, b : { $gt : 1 } } 所有的条件都要匹配上才行。
注意，上面的语句和下面是不一样的。
 t.find( { "x.a" : 1, "x.b" : { $gt : 1 } } )
$elemMatch是匹配{ "a" : 1, "b" : 3 }，而后面一句是匹配{ "b" : 99 }, { "a" : 11 } 
1)  查询嵌入对象的值

db.postings.find( { "author.name" : "joe" } );
注意用法是author.name，用一个点就行了。更详细的可以看这个链接： dot notation
举个例子：
 db.blog.save({ title : "My First Post", author: {name : "Jane", id : 1}})
如果我们要查询 authors name 是Jane的, 我们可以这样：
 db.blog.findOne({"author.name" : "Jane"})
如果不用点，那就需要用下面这句才能匹配：
db.blog.findOne({"author" : {"name" : "Jane", "id" : 1}})
下面这句：
db.blog.findOne({"author" : {"name" : "Jane"}})
是不能匹配的，因为mongodb对于子对象，他是精确匹配。

## 聚合
http://www.cnblogs.com/shanyou/archive/2012/08/05/2624073.html
```
db.system.js.save( { _id : "Sum" ,
value : function(key,values)
{
    var total = 0;
    for(var i = 0; i < values.length; i++)
        total += values[i];
    return total;
}});
db.system.js.save( { _id : "Count" ,
value : function(key,values)
{
    return values.length;
}});
```

```
use jfjun_web
db.accessinfos.runCommand(
{
mapreduce : "accessinfos",
map:function()
{
        emit(
        {key0:this.statTime,
        key1:this.userAgent},
        // Values
        this.ip);
}, 
reduce:function(key,values)
{
    var result = Count(key, values);
    return result;
},
out : { inline : 1 } });
```

### mapreduce的注意点
https://docs.mongodb.org/manual/reference/method/db.collection.mapReduce/#mapreduce-map-mtd

map：
The map function may optionally call emit(key,value) any number of times to create an output document associating key with value.
**一个map函数可以调用任意次数的emit**

reduce：
can invoke the reduce function more than once for the same key
The reduce function can access the variables defined in the scope parameter.

#  概念
mongodb中有三元素：

- 数据库，
- 集合，就是对应关系数据库中的“表”
- 文档，对应“行”；

部署：MongoDB使用的是memory-mapped file
MongoDB高度事务性的系统：例如银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序。

# 客户端
http://docs.mongodb.org/ecosystem/tools/administration-interfaces/ 
Robomongo ，开源软件，只有10M
另外还有个[mongo-express](https://github.com/andzdroid/mongo-express)，是用nodejs和express写的

# 网上培训课程-MongoDB实战
http://www.dataguru.cn/article-7129-1.html
# 系统运维
## journal太大
参考1：http://lostquery.com/questions/313/how-do-i-shrink-the-mongodb-journal-files
参考2：http://stackoverflow.com/questions/19533019/is-it-safe-to-delete-the-journal-file-of-mongodb
修改/etc/mongod.conf 的storage.smallFiles参数为空
## 只允许本地访问
bind_ip = 127.0.0.1
## 性能优化
[MongoDB 性能优化五个简单步骤](http://blog.oneapm.com/apm-tech/183.html)

## transparent huge pages

https://docs.mongodb.com/manual/tutorial/transparent-huge-pages/
## mongodump 和 Replic Set 
https://docs.mongodb.com/manual/reference/program/mongodump/

- 如果在--host前有the replica set name,将会读取主库，
  + <replSetName>/<hostname1><:port>,<hostname2><:port>,<...>
- 如果没有包含replica set name，会读取最近节点

## copyDatabase
https://docs.mongodb.com/manual/reference/method/db.copyDatabase/#db.copyDatabase
在copy时要保证有足够的磁盘空间，db.stats()表示数据库的统计信息


```
mongo $DB -u "test" -p "lingxi" --eval "db.dropDatabase();db.copyDatabase('jfjun_cw4', '$DB', 'dds-bp1aa90ef5a8a7f41.mongodb.rds.aliyuncs.com:3717', 'jfjunR', 'lingxi');"
```
尝试了copydb,但是没有成功：
```
mynonce = db.runCommand( { copydbgetnonce : 1, fromhost: 'dds-bp1aa90ef5a8a7f41.mongodb.rds.aliyuncs.com:3717' } ).nonce

hex_md5('7337108a719dd4fc' + 'jfjunR' + hex_md5('jfjunR'+":mongo:"+'lingxi'))
db.runCommand({
   copydb: 1,
   fromdb: "jfjun_cw4",
   todb: "jfjun_ml_test",
   fromhost: "dds-bp1aa90ef5a8a7f41.mongodb.rds.aliyuncs.com:3717",
   username: 'jfjunR',
   slaveOk:true,
   nonce: "7337108a719dd4fc",
   key: "28e2c60ea360baed61c18deab294dd1d"
})
```
报错：
```
{
  "ok" : 0,
  "errmsg" : "unable to login { ok: 0.0, errmsg: \"auth failed\", code: 18, codeName: \"AuthenticationFailed\" }"
}
```

但是看文档 说是只是从secondary 拷贝数据的
https://docs.mongodb.com/v2.2/tutorial/copy-databases-between-instances/#considerations
https://docs.mongodb.com/v2.2/reference/command/copydb/
- 并发
  - 源数据库不产生 point-in-time snapshots，可能会产生有分歧的数据
  - 目标数据库不加锁，可能同时会有其他操作
- 如果远端服务需要授权，需要先请求一个one-time password ，然后生成key
- 索引
  + 执行foreground builds of indexes ，会锁定数据库，阻止其它操作
  + 可以通过db.currentOp()查看当前操作

# 小工具
## 根据ObjectId获取时间
https://steveridout.github.io/mongo-object-time/

# 参考文章:
- [MongoDB权限访问控制](https://www.jianshu.com/p/ca08e63fd587)